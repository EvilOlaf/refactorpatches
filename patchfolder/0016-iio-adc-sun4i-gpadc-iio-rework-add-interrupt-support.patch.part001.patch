diff --git a/drivers/iio/adc/sun4i-gpadc-iio.c b/drivers/iio/adc/sun4i-gpadc-iio.c
index 7b12666cdd9e..77e07f042730 100644
--- a/drivers/iio/adc/sun4i-gpadc-iio.c
+++ b/drivers/iio/adc/sun4i-gpadc-iio.c
@@ -78,11 +78,14 @@ struct gpadc_data {
 	u32		ctrl2_map;
 	u32		sensor_en_map;
 	u32		filter_map;
+	u32		irq_clear_map;
+	u32		irq_control_map;
 	bool		has_bus_clk;
 	bool		has_bus_rst;
 	bool		has_mod_clk;
 	int		sensor_count;
 	bool		supports_nvmem;
+	bool		support_irq;
 };
 
 static const struct gpadc_data sun4i_gpadc_data = {
@@ -97,6 +100,7 @@ static const struct gpadc_data sun4i_gpadc_data = {
 	.sample_end = sun4i_gpadc_sample_end,
 	.sensor_count = 1,
 	.supports_nvmem = false,
+	.support_irq = false,
 };
 
 static const struct gpadc_data sun5i_gpadc_data = {
@@ -111,6 +115,7 @@ static const struct gpadc_data sun5i_gpadc_data = {
 	.sample_end = sun4i_gpadc_sample_end,
 	.sensor_count = 1,
 	.supports_nvmem = false,
+	.support_irq = false,
 };
 
 static const struct gpadc_data sun6i_gpadc_data = {
@@ -125,6 +130,7 @@ static const struct gpadc_data sun6i_gpadc_data = {
 	.sample_end = sun4i_gpadc_sample_end,
 	.sensor_count = 1,
 	.supports_nvmem = false,
+	.support_irq = false,
 };
 
 static const struct gpadc_data sun8i_a33_gpadc_data = {
@@ -136,6 +142,7 @@ static const struct gpadc_data sun8i_a33_gpadc_data = {
 	.sample_end = sun4i_gpadc_sample_end,
 	.sensor_count = 1,
 	.supports_nvmem = false,
+	.support_irq = false,
 };
 
 struct sun4i_gpadc_iio {
@@ -339,6 +346,11 @@ static int sun4i_gpadc_temp_read(struct iio_dev *indio_dev, int *val,
 		return 0;
 	}
 
+	if (info->data->support_irq) {
+		regmap_read(info->regmap, info->data->temp_data[sensor], val);
+		return 0;
+	}
+
 	return sun4i_gpadc_read(indio_dev, 0, val, info->temp_data_irq);
 }
 
@@ -436,6 +448,17 @@ static irqreturn_t sun4i_gpadc_fifo_data_irq_handler(int irq, void *dev_id)
 	return IRQ_HANDLED;
 }
 
+static irqreturn_t sunxi_irq_thread(int irq, void *data)
+{
+	struct sun4i_gpadc_iio *info = data;
+
+	regmap_write(info->regmap, SUNXI_THS_STAT, info->data->irq_clear_map);
+
+	thermal_zone_device_update(info->tzd, THERMAL_EVENT_TEMP_SAMPLE);
+
+	return IRQ_HANDLED;
+}
+
 static int sun4i_gpadc_sample_end(struct sun4i_gpadc_iio *info)
 {
 	/* Disable the ADC on IP */
@@ -448,6 +471,8 @@ static int sun4i_gpadc_sample_end(struct sun4i_gpadc_iio *info)
 
 static int sunxi_ths_sample_end(struct sun4i_gpadc_iio *info)
 {
+	/* Disable ths interrupt*/
+	regmap_write(info->regmap, SUNXI_THS_INTC, 0x0);
 	/* Disable temperature sensor */
 	regmap_write(info->regmap, SUNXI_THS_CTRL2, 0x0);
 
@@ -509,9 +534,15 @@ static int sunxi_ths_sample_start(struct sun4i_gpadc_iio *info)
 	regmap_write(info->regmap, SUNXI_THS_CTRL2,
 		info->data->ctrl2_map);
 
+	regmap_write(info->regmap, SUNXI_THS_STAT,
+			info->data->irq_clear_map);
+
 	regmap_write(info->regmap, SUNXI_THS_FILTER,
 		info->data->filter_map);
 
+	regmap_write(info->regmap, SUNXI_THS_INTC,
+		info->data->irq_control_map);
+
 	regmap_read(info->regmap, SUNXI_THS_CTRL2, &value);
 
 	regmap_write(info->regmap, SUNXI_THS_CTRL2,
@@ -625,12 +656,29 @@ static int sun4i_gpadc_probe_dt(struct platform_device *pdev,
 	struct nvmem_cell *cell;
 	ssize_t cell_size;
 	u64 *cell_data;
+	int irq;
 
 	info->data = of_device_get_match_data(&pdev->dev);
 	if (!info->data)
 		return -ENODEV;
 
-	info->no_irq = true;
+	if (info->data->support_irq) {
+		/* only the new versions of ths support right now irqs */
+		irq = platform_get_irq(pdev, 0);
+		if (irq < 0) {
+			dev_err(&pdev->dev, "failed to get IRQ: %d\n", irq);
+			return irq;
+		}
+
+		ret = devm_request_threaded_irq(&pdev->dev, irq, NULL,
+				sunxi_irq_thread, IRQF_ONESHOT,
+				dev_name(&pdev->dev), info);
+		if (ret)
+			return ret;
+
+	} else
+		info->no_irq = true;
+
 	indio_dev->num_channels = ARRAY_SIZE(sun8i_a33_gpadc_channels);
 	indio_dev->channels = sun8i_a33_gpadc_channels;
 
@@ -840,11 +888,13 @@ static int sun4i_gpadc_probe(struct platform_device *pdev)
 	if (ret)
 		return ret;
 
-	pm_runtime_set_autosuspend_delay(&pdev->dev,
-					 SUN4I_GPADC_AUTOSUSPEND_DELAY);
-	pm_runtime_use_autosuspend(&pdev->dev);
-	pm_runtime_set_suspended(&pdev->dev);
-	pm_runtime_enable(&pdev->dev);
+	if (!info->data->support_irq) {
+		pm_runtime_set_autosuspend_delay(&pdev->dev,
+						 SUN4I_GPADC_AUTOSUSPEND_DELAY);
+		pm_runtime_use_autosuspend(&pdev->dev);
+		pm_runtime_set_suspended(&pdev->dev);
+		pm_runtime_enable(&pdev->dev);
+	}
 
 	if (IS_ENABLED(CONFIG_THERMAL_OF)) {
 		for (i = 0; i < info->data->sensor_count; i++) {
@@ -865,6 +915,9 @@ static int sun4i_gpadc_probe(struct platform_device *pdev)
 		}
 	}
 
+	if (info->data->support_irq)
+		info->data->sample_start(info);
+
 	ret = devm_iio_device_register(&pdev->dev, indio_dev);
 	if (ret < 0) {
 		dev_err(&pdev->dev, "could not register the device\n");
@@ -894,6 +947,9 @@ static int sun4i_gpadc_remove(struct platform_device *pdev)
 	if (!IS_ENABLED(CONFIG_THERMAL_OF))
 		return 0;
 
+	if (info->data->support_irq)
+		info->data->sample_end(info);
+
 	thermal_zone_of_sensor_unregister(info->sensor_device, info->tzd);
 
 	if (!info->no_irq)
